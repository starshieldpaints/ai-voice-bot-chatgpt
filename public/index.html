<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>StarShield Voice Agent</title>
    <style>
      :root {
        --red: #c41230;
        --black: #111;
        --white: #ffffff;
        --gray: #f4f4f4;
        --accent: #d83b25;
        font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top right, rgba(212, 48, 56, 0.1), transparent 55%) var(--white);
        color: var(--black);
        display: flex;
        align-items: stretch;
        justify-content: center;
        padding: 2.5rem 1.5rem;
      }

      .app-shell {
        width: min(1100px, 100%);
        background: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(16px);
        border-radius: 20px;
        box-shadow: 0 25px 60px rgba(17, 17, 17, 0.12);
        overflow: hidden;
        display: grid;
        grid-template-rows: auto 1fr;
        border: 1px solid rgba(17, 17, 17, 0.05);
      }

      header {
        padding: 1.75rem 2.5rem 1.25rem;
        background: linear-gradient(135deg, var(--black), #1e1e1e);
        color: var(--white);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }

      header .title-block {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      header h1 {
        margin: 0;
        font-size: 1.75rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
      }

      header span {
        font-size: 0.9rem;
        opacity: 0.75;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      header .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.6rem 1.1rem;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        font-size: 0.85rem;
        letter-spacing: 0.05em;
      }

      header .status-badge.indicator-ok {
        color: #5ef27b;
      }

      header .status-badge.indicator-error {
        color: #ff7b7b;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 1.75rem;
        padding: 1.75rem 2.5rem 2.25rem;
      }

      .is-hidden {
        display: none !important;
      }

      .conversation-area {
        display: flex;
        flex-direction: column;
        gap: 1.75rem;
      }
      
      .conversation-actions {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.25rem;
      }

      .voice-hint {
        font-size: 0.85rem;
        color: rgba(17, 17, 17, 0.65);
        letter-spacing: 0.04em;
      }

      .lead-onboarding {
        background: rgba(255, 255, 255, 0.96);
        border-radius: 18px;
        border: 1px solid rgba(17, 17, 17, 0.05);
        padding: 1.75rem 1.75rem 1.5rem;
        box-shadow: 0 20px 34px rgba(17, 17, 17, 0.08);
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      .lead-form {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .lead-form.lead-form--locked input,
      .lead-form.lead-form--locked textarea {
        background: rgba(244, 244, 244, 0.5);
      }

      .lead-intro {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .lead-intro h2 {
        margin: 0;
        font-size: 1.2rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .lead-intro p {
        margin: 0;
        font-size: 0.95rem;
        color: rgba(17, 17, 17, 0.7);
      }

      .lead-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.25rem;
      }

      .lead-field {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .lead-field label {
        font-size: 0.78rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: rgba(17, 17, 17, 0.72);
      }

      .lead-field input,
      .lead-field textarea {
        border-radius: 12px;
        border: 1px solid rgba(17, 17, 17, 0.12);
        padding: 0.65rem 0.85rem;
        font-size: 0.95rem;
        background: rgba(244, 244, 244, 0.6);
        transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      }

      .lead-field textarea {
        resize: vertical;
        min-height: 78px;
      }

      .lead-field input:focus,
      .lead-field textarea:focus {
        outline: none;
        border-color: var(--red);
        box-shadow: 0 0 0 3px rgba(196, 18, 48, 0.18);
        background: var(--white);
      }

      .lead-field--wide {
        grid-column: span 2;
      }

      @media (max-width: 720px) {
        .lead-field--wide {
          grid-column: span 1;
        }
      }

      .lead-actions {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .lead-submit {
        align-self: flex-start;
        padding: 0.95rem 2.4rem;
        border-radius: 999px;
        border: none;
        background: var(--red);
        color: var(--white);
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        box-shadow: 0 18px 30px rgba(196, 18, 48, 0.25);
      }

      .lead-submit:hover {
        transform: translateY(-1px);
        box-shadow: 0 22px 34px rgba(196, 18, 48, 0.35);
      }

      .lead-submit:disabled {
        background: rgba(196, 18, 48, 0.4);
        box-shadow: none;
        cursor: not-allowed;
      }

      .lead-submit--voice {
        margin: 0;
      }

      .form-message {
        margin: 0;
        font-size: 0.9rem;
        min-height: 1.2rem;
        color: rgba(17, 17, 17, 0.65);
      }

      .form-message[data-status="pending"] {
        color: #c48a12;
      }

      .form-message[data-status="success"] {
        color: #0a8a2a;
      }

      .form-message[data-status="error"] {
        color: var(--red);
      }

      .conversation-feed {
        flex: 1;
        background: var(--gray);
        border-radius: 18px;
        padding: 1.75rem 1.6rem;
        border: 1px solid rgba(17, 17, 17, 0.05);
        box-shadow: inset 0 8px 18px rgba(17, 17, 17, 0.06);
        display: flex;
        flex-direction: column;
        gap: 1.1rem;
        max-height: 520px;
        overflow-y: auto;
      }

      .message {
        padding: 1rem 1.2rem;
        border-radius: 16px;
        background: var(--white);
        box-shadow: 0 12px 22px rgba(17, 17, 17, 0.08);
        border: 1px solid rgba(17, 17, 17, 0.04);
        max-width: 92%;
        line-height: 1.5;
        font-size: 0.95rem;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .message::before {
        content: attr(data-role);
        font-size: 0.75rem;
        letter-spacing: 0.15em;
        text-transform: uppercase;
        color: rgba(17, 17, 17, 0.6);
      }

      .message.user {
        margin-left: auto;
        background: linear-gradient(135deg, var(--red), #f14747);
        color: var(--white);
        box-shadow: 0 18px 26px rgba(196, 18, 48, 0.2);
        border: none;
      }

      .message.user::before {
        color: rgba(255, 255, 255, 0.7);
      }

      .message.agent {
        background: var(--white);
      }

      .message.kb {
        background: #fff4f4;
        border: 1px solid rgba(196, 18, 48, 0.2);
      }

      .message time {
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        opacity: 0.55;
      }

      .info-banner {
        background: rgba(17, 17, 17, 0.88);
        color: var(--white);
        border-radius: 14px;
        padding: 1.1rem 1.4rem;
        font-size: 0.9rem;
        letter-spacing: 0.03em;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        box-shadow: 0 15px 30px rgba(17, 17, 17, 0.18);
      }

      .info-banner strong {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 0.75rem;
        opacity: 0.65;
      }

      .input-panel {
        display: flex;
        align-items: center;
        gap: 0.9rem;
      }

      .input-panel input {
        flex: 1;
        padding: 0.9rem 1.2rem;
        border-radius: 999px;
        border: 1px solid rgba(17, 17, 17, 0.15);
        background: rgba(255, 255, 255, 0.85);
        font-size: 1rem;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .input-panel input:focus {
        outline: none;
        border-color: var(--red);
        box-shadow: 0 0 0 3px rgba(196, 18, 48, 0.15);
      }

      .input-panel button {
        padding: 0.9rem 1.8rem;
        border-radius: 999px;
        border: none;
        background: var(--black);
        color: var(--white);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        font-size: 0.8rem;
        cursor: pointer;
        transition: background 0.25s ease, transform 0.2s ease, box-shadow 0.2s ease;
      }

      .input-panel button:hover {
        background: var(--red);
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(196, 18, 48, 0.25);
      }

      .input-panel button:disabled {
        background: rgba(17, 17, 17, 0.35);
        cursor: not-allowed;
        box-shadow: none;
      }

      audio {
        display: none;
      }

      @media (max-width: 960px) {
        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <div class="title-block">
          <h1>StarShield Voice Agent</h1>
          <span>Real-time knowledge companion</span>
        </div>
        <div class="status-badge" id="statusBadge">
          <strong>Status:</strong> <span id="status">Checking...</span>
        </div>
      </header>
      <main>
        <section class="lead-onboarding" id="leadSection">
          <form id="leadForm" class="lead-form" autocomplete="off" novalidate>
            <div class="lead-intro">
              <h2>Start Your Consultation</h2>
              <p>Share your details to launch the live voice assistant.</p>
            </div>
            <div class="lead-grid">
              <div class="lead-field">
                <label for="leadName">Full name</label>
                <input id="leadName" name="name" type="text" placeholder="e.g. Ananya Sharma" required>
              </div>
              <div class="lead-field">
                <label for="leadPhone">Phone number</label>
                <input id="leadPhone" name="phone" type="tel" placeholder="+91 98765 43210" required>
              </div>
              <div class="lead-field">
                <label for="leadEmail">Email (optional)</label>
                <input id="leadEmail" name="email" type="email" placeholder="name@example.com">
              </div>
              <div class="lead-field lead-field--wide">
                <label for="leadIntent">Project focus</label>
                <textarea id="leadIntent" name="intent" rows="2" placeholder="How can StarShield help you today?" required></textarea>
              </div>
            </div>
            <div class="lead-actions">
              <button type="submit" class="lead-submit" id="leadSubmitButton">
                Start Voice Consultation
              </button>
              <p id="leadFormMessage" class="form-message" role="status" aria-live="polite"></p>
            </div>
          </form>
        </section>
        <section class="conversation-area is-hidden" id="conversationSection">
          <div class="conversation-actions is-hidden" id="conversationActions">
            <span class="voice-hint">Use the button to start or stop the live voice consultation.</span>
          </div>
          <div class="conversation-feed" id="conversation"></div>
          <form id="textForm" class="input-panel" autocomplete="off">
            <input
              id="textInput"
              type="text"
              placeholder="Ask a question or describe a StarShield scenario…"
              disabled
            >
            <button type="submit">Send</button>
          </form>
          <div class="info-banner">
            <strong>Tip</strong>
            <span>Ask about any StarShield product or scenario. The agent will respond and display a written summary here.</span>
          </div>
        </section>
      </main>
    </div>
    <audio id="assistantAudio" autoplay></audio>
    <script>
      const statusEl = document.getElementById("status");
      const statusBadge = document.getElementById("statusBadge");
      const leadSection = document.getElementById("leadSection");
      const leadForm = document.getElementById("leadForm");
      const leadNameInput = document.getElementById("leadName");
      const leadPhoneInput = document.getElementById("leadPhone");
      const leadEmailInput = document.getElementById("leadEmail");
      const leadIntentInput = document.getElementById("leadIntent");
      const leadFormMessage = document.getElementById("leadFormMessage");
      const leadSubmitButton = document.getElementById("leadSubmitButton");
      const audioEl = document.getElementById("assistantAudio");
      const conversationEl = document.getElementById("conversation");
      const conversationSection = document.getElementById("conversationSection");
      const conversationActions = document.getElementById("conversationActions");
      const textForm = document.getElementById("textForm");
      const textInput = document.getElementById("textInput");

      let pc;
      let mic;
      let dataChannel;
      const transcriptBuffer = new Map();
      const processedInputItems = new Set();
      const cachedSearchSummaries = new Map();
      const pendingTypedMessages = [];
      let isStartingSession = false;
      let isConversationVisible = false;
      let isVoiceConnected = false;
      let hasPromotedVoiceButton = false;
      let voiceControlButton = leadSubmitButton;
      const leadState = {
        submitted: false,
        payload: null,
        leadId: null,
        source: ""
      };
      const RAW_API_BASE =
        window.API_BASE_URL ||
        (window.location.hostname === "localhost"
          ? ""
          : "https://voice-agent-1058353954635.us-central1.run.app");
      const API_BASE = RAW_API_BASE.replace(/\/$/, "");
      const apiUrl = path => {
        const normalizedPath = path.startsWith("/") ? path : `/${path}`;
        return `${API_BASE}${normalizedPath}`;
      };

      setLeadFormMessage("Enter your details to create a lead and start the voice assistant.");
      setConversationVisible(false);
      setLeadSectionVisible(true);

      function setStatus(message, type = "") {
        statusEl.textContent = message;
        statusBadge.classList.remove("indicator-ok", "indicator-error");
        if (type === "ok") statusBadge.classList.add("indicator-ok");
        else if (type === "error") statusBadge.classList.add("indicator-error");
      }

      function logEvent(message) {
        console.log("[Agent]", message);
      }

      function appendMessage(role, message) {
        const clean = (message || "").trim();
        if (!clean) return;
        const wrapper = document.createElement("div");
        wrapper.classList.add("message", role);
        const roleLabel =
          role === "user" ? "You" : role === "agent" ? "Assistant" : "Knowledge";
        wrapper.setAttribute("data-role", roleLabel);

        const body = document.createElement("div");
        body.textContent = clean;
        wrapper.appendChild(body);

        const time = document.createElement("time");
        time.textContent = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit"
        });
        wrapper.appendChild(time);

        conversationEl.appendChild(wrapper);
        conversationEl.scrollTop = conversationEl.scrollHeight;
      }

      function setLeadFormMessage(message, status = "") {
        if (!leadFormMessage) return;
        const text = (message || "").trim();
        leadFormMessage.textContent = text;
        if (status) {
          leadFormMessage.setAttribute("data-status", status);
        } else {
          leadFormMessage.removeAttribute("data-status");
        }
      }

      function toggleLeadInputs(disabled) {
        if (!leadForm) return;
        leadForm.querySelectorAll("input, textarea").forEach(el => {
          el.disabled = disabled;
        });
        if (leadSubmitButton) leadSubmitButton.disabled = disabled;
      }

      function setLeadSectionVisible(visible) {
        if (!leadSection) return;
        leadSection.classList.toggle("is-hidden", !visible);
      }

      function setConversationVisible(visible) {
        isConversationVisible = visible;
        if (conversationSection) {
          conversationSection.classList.toggle("is-hidden", !visible);
        }
        if (textInput) {
          textInput.disabled = !visible;
        }
        if (conversationActions) {
          conversationActions.classList.toggle(
            "is-hidden",
            !visible || !hasPromotedVoiceButton
          );
        }
      }

      function promoteButtonToVoiceControl() {
        if (!voiceControlButton || hasPromotedVoiceButton || !conversationActions) return;
        hasPromotedVoiceButton = true;
        voiceControlButton.type = "button";
        voiceControlButton.classList.add("lead-submit--voice");
        voiceControlButton.textContent = "Connecting...";
        voiceControlButton.disabled = true;
        conversationActions.classList.remove("is-hidden");
        conversationActions.prepend(voiceControlButton);
        voiceControlButton.addEventListener("click", handleVoiceToggle);
      }

      function setVoiceButtonState(state) {
        if (!voiceControlButton) return;
        switch (state) {
          case "connecting":
            voiceControlButton.disabled = true;
            voiceControlButton.textContent = "Connecting...";
            voiceControlButton.dataset.mode = "connecting";
            break;
          case "active":
            voiceControlButton.disabled = false;
            voiceControlButton.textContent = "Stop Voice Consultation";
            voiceControlButton.dataset.mode = "stop";
            break;
          default:
            voiceControlButton.disabled = false;
            voiceControlButton.textContent = "Start Voice Consultation";
            voiceControlButton.dataset.mode = "start";
        }
      }

      function handleVoiceToggle() {
        if (isStartingSession) return;
        if (isVoiceConnected) {
          setStatus("Stopping voice session…");
          stopVoice();
        } else {
          setStatus("Reconnecting voice session…");
          startVoice();
        }
      }

      function getLeadFormValues() {
        return {
          name: (leadNameInput?.value || "").trim(),
          phone: (leadPhoneInput?.value || "").trim(),
          email: (leadEmailInput?.value || "").trim(),
          intent: (leadIntentInput?.value || "").trim()
        };
      }

      function normalizeWhitespace(text = "") {
        return text.replace(/\s+/g, " ").trim();
      }

      function summarizeSnippet(snippet = "", fallbackTitle = "this product") {
        const lines = snippet
          .split(/\r?\n/)
          .map(line => normalizeWhitespace(line))
          .filter(Boolean);

        const info = {
          product: "",
          oneLiner: "",
          description: "",
          component: "",
          coverageNew: "",
          coverageRepaint: "",
          coats: "",
          uv: "",
          problem: ""
        };

        let currentKey = "";
        for (const line of lines) {
          if (line.toLowerCase().startsWith("product name")) {
            currentKey = "product";
            info.product = line.replace(/product name/i, "").trim();
          } else if (line.toLowerCase().startsWith("one liner")) {
            currentKey = "oneLiner";
            info.oneLiner = line.replace(/one liner.*/i, "").trim();
          } else if (line.toLowerCase().startsWith("one liner about product")) {
            currentKey = "oneLiner";
            info.oneLiner = line.replace(/one liner about product/i, "").trim();
          } else if (line.toLowerCase().startsWith("description")) {
            currentKey = "description";
            info.description = line.replace(/description/i, "").trim();
          } else if (line.toLowerCase().startsWith("component")) {
            currentKey = "component";
            info.component = line.replace(/component/i, "").trim();
          } else if (line.toLowerCase().includes("coverage") && line.toLowerCase().includes("new")) {
            currentKey = "coverageNew";
            info.coverageNew = line.replace(/coverage.*new.*/i, "").trim();
          } else if (line.toLowerCase().includes("coverage") && line.toLowerCase().includes("repaint")) {
            currentKey = "coverageRepaint";
            info.coverageRepaint = line.replace(/coverage.*paint.*/i, "").trim();
          } else if (line.toLowerCase().startsWith("recommended coat")) {
            currentKey = "coats";
            info.coats = line.replace(/recommended coat.*?/i, "").trim();
          } else if (line.toLowerCase().includes("uv")) {
            currentKey = "uv";
            info.uv = line.replace(/is this uv stable\??/i, "").replace(/uv stability?/i, "").trim();
          } else if (line.toLowerCase().startsWith("problem statement")) {
            currentKey = "problem";
            info.problem = line.replace(/problem statement.*?/i, "").trim();
          } else if (/^http/i.test(line) || /^url:/i.test(line)) {
            continue;
          } else if (currentKey) {
            info[currentKey] = (info[currentKey] ? info[currentKey] + " " : "") + line;
          }
        }

        const productName = info.product || fallbackTitle;
        const description =
          info.oneLiner ||
          info.description ||
          `I found details on ${productName}, but the summary is limited.`;

        const details = [];
        if (info.component) details.push(`Component: ${info.component}`);
        if (info.uv) details.push(`UV stability: ${info.uv}`);
        if (info.problem) details.push(`Solves: ${info.problem}`);
        if (info.coverageNew) details.push(`Coverage (new surface): ${info.coverageNew}`);
        if (info.coverageRepaint) details.push(`Coverage (repaint): ${info.coverageRepaint}`);
        if (info.coats) details.push(`Recommended coats: ${info.coats}`);

        return { productName, description, bulletPoints: details };
      }

      function formatSearchSummary(items) {
        if (!Array.isArray(items) || items.length === 0) {
          return "StarShield is a protective coatings and advanced paints company. I couldn't find matching information in the StarShield knowledge base, so ask follow-up questions about our paint and coating solutions.";
        }

        const [primary] = items;
        const cleaned = summarizeSnippet(primary?.snippet, primary?.title);
        let narrative = `StarShield is a protective coatings and advanced paints company. The most relevant insight about ${cleaned.productName} is: ${cleaned.description}`;

        if (cleaned.bulletPoints.length) {
          narrative += ` Important details include ${cleaned.bulletPoints.join("; ")}.`;
        }

        return narrative;
      }

      async function performSearchAndShare(query, { triggerResponse = false } = {}) {
        const cleaned = (query || "").trim();
        if (!cleaned) {
          if (triggerResponse && dataChannel && dataChannel.readyState === "open") {
            dataChannel.send(JSON.stringify({ type: "response.create" }));
          }
          return;
        }

        try {
          const rawResults = await callToolEndpoint("search_docs", {
            query: cleaned
          });
          const items = Array.isArray(rawResults?.results)
            ? rawResults.results
            : [];
          const lower = cleaned.toLowerCase();
          let summary = cachedSearchSummaries.get(lower);
          let isNewSummary = false;
          if (!summary) {
            summary = formatSearchSummary(items);
            cachedSearchSummaries.set(lower, summary);
            isNewSummary = true;
          }

          logEvent(`Auto search summary:\n${summary}`);

          const shouldSendSummary =
            isNewSummary || !processedInputItems.has(`summary-${lower}`);

          if (
            shouldSendSummary &&
            dataChannel &&
            dataChannel.readyState === "open"
          ) {
            dataChannel.send(
              JSON.stringify({
                type: "conversation.item.create",
                item: {
                  type: "message",
                  role: "system",
                  content: [
                    {
                      type: "input_text",
                      text: `Knowledge base summary for later use:\n${summary}\n\nDo not use this information until you have confirmed the customer's name and phone number. When you do reference it, respond conversationally without exposing document titles or raw notes.`
                    }
                  ]
                }
              })
            );
            processedInputItems.add(`summary-${lower}`);
            if (triggerResponse) {
              dataChannel.send(JSON.stringify({ type: "response.create" }));
            }
          }
        } catch (err) {
          logEvent(`search_docs failed: ${err.message}`);
          if (triggerResponse && dataChannel && dataChannel.readyState === "open") {
            dataChannel.send(JSON.stringify({ type: "response.create" }));
          }
        }
      }

      async function callToolEndpoint(name, payload = {}) {
        const response = await fetch(apiUrl(`/tool/${name}`), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });

        const text = await response.text();
        let data;
        try {
          data = text ? JSON.parse(text) : null;
        } catch {
          data = text;
        }

        if (!response.ok) {
          const errorMessage =
            (data && typeof data === "object" && data.error) ||
            (typeof data === "string" && data) ||
            response.statusText ||
            `Tool ${name} failed`;
          throw new Error(errorMessage);
        }

        return data ?? {};
      }

      function sendToolResult(callId, output, { startResponse = true } = {}) {
        if (!dataChannel || dataChannel.readyState !== "open") return;

        dataChannel.send(
          JSON.stringify({
            type: "conversation.item.create",
            item: {
              type: "function_call_output",
              call_id: callId,
              output
            }
          })
        );

        if (startResponse) {
          dataChannel.send(JSON.stringify({ type: "response.create" }));
        }
      }

      async function handleFunctionCall(call) {
        try {
          const toolName = (call.name || "").trim();
          if (!toolName) {
            throw new Error("Tool call missing name");
          }
          const args = call.arguments ? JSON.parse(call.arguments) : {};
          let result;

          switch (toolName) {
            case "search_docs": {
              if (!args.query) {
                throw new Error("search_docs requires a query string");
              }
              const normalizedQuery = args.query.trim().toLowerCase();
              let summary;
              if (normalizedQuery && cachedSearchSummaries.has(normalizedQuery)) {
                summary = cachedSearchSummaries.get(normalizedQuery);
              } else {
                const payload = { query: args.query };
                if (typeof args.top_k === "number") {
                  payload.top_k = args.top_k;
                }
                const rawResults = await callToolEndpoint("search_docs", payload);
                const items = Array.isArray(rawResults?.results)
                  ? rawResults.results
                  : [];
                summary = formatSearchSummary(items);
                if (normalizedQuery) {
                  cachedSearchSummaries.set(normalizedQuery, summary);
                }
              }
              logEvent(`Tool search_docs summary:\n${summary}`);
              result = summary;
              break;
            }
            case "create_lead": {
              const { name, phone, intent, email } = args;
              if (!name || !phone || !intent) {
                throw new Error(
                  "create_lead requires name, phone, and intent fields"
                );
              }
              result = await callToolEndpoint("create_lead", {
                name,
                phone,
                intent,
                email
              });
              break;
            }
            default:
              throw new Error(`Unknown tool requested: ${toolName}`);
          }

          logEvent(`Tool ${toolName} succeeded`);
          sendToolResult(call.callId, result);
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "Tool call failed";
          const safeName = (call.name || "").trim() || "unknown";
          logEvent(`Tool ${safeName} failed: ${message}`);
          sendToolResult(call.callId, { error: message, tool: safeName });
        }
      }

      async function ping() {
        try {
          const response = await fetch(apiUrl("/health"));
          if (!response.ok) throw new Error("Health check failed");
          const payload = await response.json();
          setStatus(payload.ok ? "Ready" : "Backend health check failed", payload.ok ? "ok" : "error");
        } catch (err) {
          console.error(err);
          setStatus("Backend not reachable", "error");
        }
      }
      ping();

      async function handleLeadSubmit(evt) {
        evt.preventDefault();
        if (isStartingSession) return;

        const { name, phone, email, intent } = getLeadFormValues();

        if (!leadState.submitted) {
          if (!name || !phone || !intent) {
            setLeadFormMessage("Please add your name, phone number, and project focus to begin.", "error");
            return;
          }

          setLeadFormMessage("Syncing your details", "pending");
          toggleLeadInputs(true);

          const payload = { name, phone, intent };
          if (email) {
            payload.email = email;
          }

          try {
            const result = await callToolEndpoint("create_lead", payload);
            const source = (result?.source || "").toLowerCase();
            leadState.submitted = true;
            leadState.payload = { name, phone, email, intent };
            leadState.leadId = result?.lead_id || null;
            leadState.source = source || "";
            leadForm?.classList.add("lead-form--locked");
            setConversationVisible(true);
            setLeadSectionVisible(false);
            conversationSection?.scrollIntoView({ behavior: "smooth", block: "start" });
            promoteButtonToVoiceControl();
            const successStatus = source === "dynamics365" ? "success" : "pending";
            const successMessage =
              source === "dynamics365"
                ? "Lead saved. Connecting you now..."
                : "Lead captured locally.Credentials are not configured yet.";
            setLeadFormMessage(successMessage, successStatus);
          } catch (err) {
            toggleLeadInputs(false);
            const message =
              err && typeof err.message === "string"
                ? err.message
                : "We couldn't reach CRM. Please verify your CRM credentials and try again.";
            setLeadFormMessage(message, "error");
            return;
          }
        } else {
          setLeadFormMessage("Reconnecting the voice session...", "pending");
          setConversationVisible(true);
          setLeadSectionVisible(false);
          conversationSection?.scrollIntoView({ behavior: "smooth", block: "start" });
          promoteButtonToVoiceControl();
        }

        try {
          setVoiceButtonState("connecting");
          await startVoice();
          const connectedMessage =
            leadState.source === "dynamics365"
              ? "You're connected. You can speak now or type a message below."
              : leadState.source === "stub"
              ? "You're connected. You can speak now or type a message below. (Lead stored locally until CRM is configured.)"
              : "You're connected. You can speak now or type a message below.";
          setLeadFormMessage(connectedMessage, "success");
        } catch (err) {
          setVoiceButtonState("ready");
          if (!leadState.submitted) {
            toggleLeadInputs(false);
          }
          const message =
            err && typeof err.message === "string"
              ? err.message
              : "Unable to start the voice session. Please retry.";
          setLeadFormMessage(message, "error");
        }
      }

      async function startVoice() {
        if (isStartingSession) return;
        try {
          isStartingSession = true;
          setVoiceButtonState("connecting");
          setStatus("Creating real-time session...");
          logEvent("Requesting ephemeral session from backend");
          conversationEl.innerHTML = "";
          transcriptBuffer.clear();
          processedInputItems.clear();
          cachedSearchSummaries.clear();
          pendingTypedMessages.length = 0;
          appendMessage("agent", "Voice session is live. I'm ready to help with any StarShield project questions.");

          const sessionResponse = await fetch(apiUrl("/session"));
          const sessionPayload = await sessionResponse.json().catch(() => ({}));
          if (!sessionResponse.ok) {
            throw new Error(sessionPayload.error || "Unable to obtain session from backend");
          }
          const sessionToken = sessionPayload?.client_secret?.value ?? sessionPayload?.client_secret;
          if (!sessionToken) {
            throw new Error("Backend response missing client_secret");
          }

          pc = new RTCPeerConnection({
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" }
            ]
          });

          pc.addEventListener("track", event => {
            audioEl.srcObject = event.streams[0];
          });

          pc.addEventListener("connectionstatechange", () => {
            logEvent(`Peer connection state: ${pc.connectionState}`);
          });

          dataChannel = pc.createDataChannel("oai-events");
          dataChannel.addEventListener("open", () => {
            logEvent("Data channel opened");
            const brandPrimer = [
              "You are the StarShield paints assistant for an Indian company that specializes in advanced paints, waterproofing, insulation, and protective coatings. Never refer to StarShield as a security or defense company.",
              "The customer's contact information was already collected in the onboarding form. Do not ask for their name or phone number again; instead, acknowledge their project and move forward.",
              "Open with a warm greeting, confirm the project intent captured in the form, and keep every reply focused on StarShield's paints and surface-protection solutions.",
              "Never expose raw knowledge-base snippets, file names, or document titles to customers; weave the information into natural responses.",
              "Do not share or mention any URLs, links, or document addresses with customers. Offer summaries instead."
            ].join("\n");
            dataChannel.send(
              JSON.stringify({
                type: "conversation.item.create",
                item: {
                  type: "message",
                  role: "system",
                  content: [
                    {
                      type: "input_text",
                      text: `${brandPrimer}\nAcknowledge these brand guardrails silently and comply in all responses.`
                    }
                  ]
                }
              })
            );
            if (leadState.payload) {
              const { name, phone, email, intent } = leadState.payload;
              const details = [
                name ? `Customer name: ${name}` : "",
                phone ? `Customer phone: ${phone}` : "",
                email ? `Customer email: ${email}` : "",
                intent ? `Project focus: ${intent}` : ""
              ]
                .filter(Boolean)
                .join("\n");

              if (details) {
                dataChannel.send(
                  JSON.stringify({
                    type: "conversation.item.create",
                    item: {
                      type: "message",
                      role: "system",
                      content: [
                        {
                          type: "input_text",
                          text: `Onboarding form details (already confirmed with the customer):\n${details}\n\nDo not prompt the customer for these again. Acknowledge them politely and move straight into tailored guidance.`
                        }
                      ]
                    }
                  })
                );
              }
            }
          });
          dataChannel.addEventListener("close", () => logEvent("Data channel closed"));
          dataChannel.addEventListener("message", evt => {
            let payload;
            try {
              payload = JSON.parse(evt.data);
            } catch {
              logEvent(`Agent event: ${evt.data}`);
              return;
            }

            switch (payload.type) {
              case "conversation.item.created": {
                const item = payload.item;
                if (
                  item?.type === "message" &&
                  item.role === "user" &&
                  Array.isArray(item.content)
                ) {
                  const textPart = item.content.find(
                    entry => entry?.type === "input_text" && entry.text
                  );
                  if (textPart && !processedInputItems.has(item.id)) {
                    const normalized = textPart.text.trim().toLowerCase();
                    const pendingIndex = pendingTypedMessages.findIndex(
                      val => val === normalized
                    );
                    if (pendingIndex >= 0) {
                      pendingTypedMessages.splice(pendingIndex, 1);
                    } else {
                      appendMessage("user", textPart.text);
                      performSearchAndShare(textPart.text, { triggerResponse: true });
                    }
                    processedInputItems.add(item.id);
                  }
                }
                break;
              }
              case "conversation.item.input_audio_transcription.delta": {
                const delta = typeof payload.delta === "string" ? payload.delta : "";
                if (delta) {
                  const key = `user-${payload.item_id}`;
                  const previous = transcriptBuffer.get(key) || "";
                  transcriptBuffer.set(key, previous + delta);
                }
                break;
              }
              case "conversation.item.input_audio_transcription.completed": {
                const key = `user-${payload.item_id}`;
                const finalTranscript =
                  (typeof payload.transcript === "string" && payload.transcript) ||
                  transcriptBuffer.get(key) ||
                  "";
                if (finalTranscript) {
                  appendMessage("user", finalTranscript.trim());
                  transcriptBuffer.delete(key);
                  if (!processedInputItems.has(payload.item_id)) {
                    processedInputItems.add(payload.item_id);
                    performSearchAndShare(finalTranscript, { triggerResponse: true });
                  }
                }
                break;
              }
              case "function_call":
                logEvent(`Tool requested: ${(payload.name || "").trim() || "unknown"}`);
                handleFunctionCall(payload);
                break;
              case "response.output_text.delta": {
                const key = `text-${payload.item_id}`;
                const existing = transcriptBuffer.get(key) || "";
                const delta = typeof payload.delta === "string" ? payload.delta : "";
                if (delta) {
                  transcriptBuffer.set(key, existing + delta);
                  logEvent(`Agent: ${delta}`);
                }
                break;
              }
              case "response.output_text.done": {
                const key = `text-${payload.item_id}`;
                let final = "";
                if (Array.isArray(payload.output_text)) {
                  final = payload.output_text.join("");
                } else if (typeof payload.output_text === "string") {
                  final = payload.output_text;
                } else {
                  final = transcriptBuffer.get(key) || "";
                }
                if (final) appendMessage("agent", final.trim());
                transcriptBuffer.delete(key);
                break;
              }
              case "response.audio_transcript.delta": {
                const delta = typeof payload.delta === "string" ? payload.delta : "";
                if (delta) {
                  const previous = transcriptBuffer.get(payload.item_id) || "";
                  transcriptBuffer.set(payload.item_id, previous + delta);
                }
                break;
              }
              case "response.audio_transcript.done": {
                const final =
                  (typeof payload.transcript === "string" && payload.transcript) ||
                  transcriptBuffer.get(payload.item_id) ||
                  "";
                if (final) appendMessage("agent", final.trim());
                transcriptBuffer.delete(payload.item_id);
                break;
              }
              default:
                logEvent(`Agent event: ${evt.data}`);
            }
          });

          setStatus("Requesting microphone...");
          mic = await navigator.mediaDevices.getUserMedia({ audio: true });
          mic.getTracks().forEach(track => pc.addTrack(track, mic));

          setStatus("Sending offer to OpenAI...");
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);

          const realtimeResponse = await fetch(
            `https://api.openai.com/v1/realtime?model=${encodeURIComponent(sessionPayload.model || sessionPayload.default_model || "gpt-realtime-mini-2025-10-06")}`,
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${sessionToken}`,
                "Content-Type": "application/sdp",
                "OpenAI-Beta": "realtime=v1"
              },
              body: offer.sdp
            }
          );

          const answer = await realtimeResponse.text();
          if (!realtimeResponse.ok) {
            throw new Error(`Realtime handshake failed: ${answer}`);
          }

          await pc.setRemoteDescription({ type: "answer", sdp: answer });

          logEvent("Realtime session ready");
          setStatus("Connected", "ok");
          isVoiceConnected = true;
          setVoiceButtonState("active");
          isStartingSession = false;
        } catch (err) {
          console.error(err);
          setStatus(err.message || "Failed to start voice session", "error");
          isStartingSession = false;
          stopVoice({ silent: true });
          setVoiceButtonState("ready");
        }
      }

      function stopVoice({ silent = false } = {}) {
        isStartingSession = false;
        if (mic) {
          mic.getTracks().forEach(track => track.stop());
          mic = undefined;
        }
        if (dataChannel && dataChannel.readyState !== "closed") {
          dataChannel.close();
        }
        if (pc) {
          pc.close();
          pc = undefined;
        }
        isVoiceConnected = false;
        setVoiceButtonState("ready");
        if (!silent) {
          setStatus("Stopped");
          setLeadFormMessage(
            leadState.submitted
              ? "Session stopped. Press start to reconnect when you're ready."
              : "Session stopped. Submit the form to start a new voice session.",
            "pending"
          );
        }
        logEvent("Voice session stopped");
      }

      if (leadForm) {
        leadForm.addEventListener("submit", handleLeadSubmit);
      }
      textForm.addEventListener("submit", async evt => {
        evt.preventDefault();
        if (!isConversationVisible) {
          setLeadFormMessage("Submit your details above to unlock the assistant.", "pending");
          return;
        }
        const message = (textInput.value || "").trim();
        if (!message) return;

        if (!dataChannel || dataChannel.readyState !== "open") {
          appendMessage("agent", "Voice session is not connected yet. Tap the voice consultation button to connect.");
          return;
        }

        const eventCreate = {
          type: "conversation.item.create",
          item: {
            type: "message",
            role: "user",
            content: [
              {
                type: "input_text",
                text: message
              }
            ]
          }
        };

        try {
          dataChannel.send(JSON.stringify(eventCreate));
          appendMessage("user", message);
          processedInputItems.add(`typed-${Date.now()}`);
          textInput.value = "";
          pendingTypedMessages.push(message.toLowerCase());
          await performSearchAndShare(message, { triggerResponse: true });
        } catch (err) {
          console.error(err);
          appendMessage("agent", "I couldn't send that message—please retry after reconnecting.");
        }
      });

      window.addEventListener("beforeunload", () => stopVoice({ silent: true }));
    </script>
  </body>
</html>


